<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Strongly Connected Components - Interactive Learning</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f5f5f5;
            min-height: 100vh;
        }

        .nav-bar {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            padding: 15px 30px;
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .nav-bar a {
            color: white;
            text-decoration: none;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .nav-bar h1 {
            color: white;
            font-size: 1.5em;
            flex: 1;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 40px 20px;
        }

        .card {
            background: white;
            border-radius: 16px;
            padding: 30px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            margin-bottom: 25px;
        }

        .card h2 {
            font-size: 1.8em;
            color: #1a1a2e;
            margin-bottom: 20px;
            border-bottom: 3px solid #ef4444;
            padding-bottom: 10px;
        }

        .card h3 {
            font-size: 1.3em;
            color: #1a1a2e;
            margin: 25px 0 15px 0;
        }

        .card p {
            color: #555;
            line-height: 1.8;
            margin-bottom: 15px;
        }

        .card ul,
        .card ol {
            margin-left: 25px;
            color: #555;
            line-height: 1.8;
            margin-bottom: 15px;
        }

        .card li {
            margin-bottom: 8px;
        }

        .info-box {
            background: #fef2f2;
            border: 2px solid #ef4444;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }

        .info-box h4 {
            color: #dc2626;
            margin-bottom: 10px;
        }

        .info-box p,
        .info-box li {
            color: #991b1b;
            line-height: 1.6;
        }

        .info-box ul {
            margin-left: 20px;
        }

        .algorithm-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .algorithm-card {
            background: #fef2f2;
            border-left: 4px solid #ef4444;
            padding: 20px;
            border-radius: 0 8px 8px 0;
        }

        .algorithm-card h4 {
            color: #991b1b;
            margin-bottom: 10px;
        }

        .algorithm-card p {
            color: #7f1d1d;
            margin: 0;
        }

        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }

        .comparison-table th,
        .comparison-table td {
            padding: 12px 15px;
            border: 1px solid #e0e0e0;
            text-align: left;
        }

        .comparison-table th {
            background: #ef4444;
            color: white;
        }

        .comparison-table tr:nth-child(even) {
            background: #f8f8f8;
        }

        .nav-buttons {
            display: flex;
            justify-content: space-between;
            margin-top: 40px;
            padding-top: 30px;
            border-top: 2px solid #e0e0e0;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            text-decoration: none;
        }

        .btn-primary {
            background: #ef4444;
            color: white;
        }

        .btn-secondary {
            background: white;
            color: #1a1a2e;
            border: 2px solid #e0e0e0;
        }

        .code-box {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
            border-radius: 8px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 13px;
            margin: 15px 0;
            overflow-x: auto;
            line-height: 1.6;
        }

        .code-box .keyword {
            color: #569cd6;
        }

        .code-box .comment {
            color: #6a9955;
        }

        .code-box .function {
            color: #dcdcaa;
        }

        .code-box .number {
            color: #b5cea8;
        }

        .diagram-box {
            background: #f0f0f0;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
            font-family: monospace;
        }

        .step-list {
            counter-reset: step-counter;
            list-style: none;
            margin-left: 0;
        }

        .step-list li {
            counter-increment: step-counter;
            margin-bottom: 15px;
            padding-left: 45px;
            position: relative;
        }

        .step-list li::before {
            content: counter(step-counter);
            position: absolute;
            left: 0;
            top: 0;
            background: #ef4444;
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 14px;
        }
    </style>
</head>

<body>
    <div class="nav-bar">
        <a href="index.html"><i class="fas fa-home"></i> Home</a>
        <h1><i class="fas fa-compress-arrows-alt"></i> Strongly Connected Components</h1>
        <a href="flow-networks.html">Next: Flow Networks <i class="fas fa-arrow-right"></i></a>
    </div>

    <div class="container">
        <div class="card">
            <h2>What are Strongly Connected Components?</h2>
            <p>A <strong>Strongly Connected Component (SCC)</strong> of a directed graph is a maximal set of vertices
                such that there is a path from every vertex to every other vertex in the set. In other words, all
                vertices in an SCC can reach each other.</p>

            <div class="info-box">
                <h4><i class="fas fa-key"></i> Key Properties</h4>
                <ul>
                    <li>SCCs partition the graph — every vertex belongs to exactly one SCC</li>
                    <li>A vertex with no edges forms its own SCC</li>
                    <li>If we collapse each SCC to a single node, the resulting graph (condensation) is a DAG</li>
                </ul>
            </div>

            <div class="diagram-box">
                <pre>
Original Graph:                    SCCs Identified:
                                   
    1 → 2 → 3                     SCC1: {1, 2, 3}  (cycle)
    ↑   ↓   ↓                     SCC2: {4}
    └───┤   ↓                     SCC3: {5, 6}     (cycle)
        ↓   ↓                     
        4 → 5 ⟷ 6                 
                                   Condensation Graph:
                                   SCC1 → SCC2 → SCC3
                </pre>
            </div>
        </div>

        <div class="card">
            <h2>Applications</h2>
            <div class="algorithm-grid">
                <div class="algorithm-card">
                    <h4><i class="fas fa-check-double"></i> 2-SAT Problems</h4>
                    <p>Solving 2-satisfiability using implication graphs and SCCs.</p>
                </div>
                <div class="algorithm-card">
                    <h4><i class="fas fa-code"></i> Dead Code Detection</h4>
                    <p>Finding unreachable code in control flow graphs.</p>
                </div>
                <div class="algorithm-card">
                    <h4><i class="fas fa-users"></i> Social Network Analysis</h4>
                    <p>Finding communities where all members are mutually connected.</p>
                </div>
                <div class="algorithm-card">
                    <h4><i class="fas fa-project-diagram"></i> Compiler Optimization</h4>
                    <p>Analyzing dependencies in program analysis.</p>
                </div>
            </div>
        </div>

        <div class="card">
            <h2>Kosaraju's Algorithm</h2>
            <p>Kosaraju's algorithm finds SCCs using <strong>two DFS passes</strong> — one on the original graph and one
                on the reversed graph.</p>

            <h3>Algorithm Steps</h3>
            <ol class="step-list">
                <li><strong>First DFS:</strong> Perform DFS on the original graph, recording vertices by finish time
                    (push to stack when done)</li>
                <li><strong>Reverse the graph:</strong> Create a graph with all edges reversed (transposed)</li>
                <li><strong>Second DFS:</strong> Process vertices in decreasing finish time order (pop from stack), run
                    DFS on reversed graph. Each DFS tree is one SCC.</li>
            </ol>

            <div class="info-box">
                <h4><i class="fas fa-lightbulb"></i> Why It Works</h4>
                <p>In the first DFS, vertices in "sink" SCCs (no outgoing edges to other SCCs) finish last. When we
                    reverse edges, these become "source" SCCs. Processing in reverse finish time order ensures we visit
                    complete SCCs before jumping to others.</p>
            </div>

            <div class="code-box">
                <span class="keyword">function</span> <span class="function">kosaraju</span>(graph, n):
                visited = [<span class="keyword">false</span>] * n
                stack = []

                <span class="comment">// Step 1: First DFS to fill stack by finish time</span>
                <span class="keyword">for</span> v = <span class="number">0</span> <span class="keyword">to</span>
                n-<span class="number">1</span>:
                <span class="keyword">if not</span> visited[v]:
                <span class="function">dfs1</span>(v, graph, visited, stack)

                <span class="comment">// Step 2: Create reversed graph</span>
                reversed = <span class="function">reverseGraph</span>(graph, n)

                <span class="comment">// Step 3: Second DFS in stack order</span>
                visited = [<span class="keyword">false</span>] * n
                sccs = []

                <span class="keyword">while</span> stack <span class="keyword">not</span> empty:
                v = stack.pop()
                <span class="keyword">if not</span> visited[v]:
                component = []
                <span class="function">dfs2</span>(v, reversed, visited, component)
                sccs.append(component)

                <span class="keyword">return</span> sccs

                <span class="keyword">function</span> <span class="function">dfs1</span>(v, graph, visited, stack):
                visited[v] = <span class="keyword">true</span>
                <span class="keyword">for</span> u <span class="keyword">in</span> graph[v]:
                <span class="keyword">if not</span> visited[u]:
                <span class="function">dfs1</span>(u, graph, visited, stack)
                stack.push(v) <span class="comment">// Add when finished</span>

                <span class="keyword">function</span> <span class="function">dfs2</span>(v, reversed, visited,
                component):
                visited[v] = <span class="keyword">true</span>
                component.append(v)
                <span class="keyword">for</span> u <span class="keyword">in</span> reversed[v]:
                <span class="keyword">if not</span> visited[u]:
                <span class="function">dfs2</span>(u, reversed, visited, component)

                <span class="keyword">function</span> <span class="function">reverseGraph</span>(graph, n):
                reversed = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]
                <span class="keyword">for</span> v = <span class="number">0</span> <span class="keyword">to</span>
                n-<span class="number">1</span>:
                <span class="keyword">for</span> u <span class="keyword">in</span> graph[v]:
                reversed[u].append(v)
                <span class="keyword">return</span> reversed
            </div>
        </div>

        <div class="card">
            <h2>Tarjan's Algorithm</h2>
            <p>Tarjan's algorithm finds SCCs in a <strong>single DFS pass</strong> using the concept of <strong>low-link
                    values</strong>.</p>

            <h3>Key Concepts</h3>
            <ul>
                <li><strong>Discovery Time (disc):</strong> When a vertex is first visited</li>
                <li><strong>Low-Link Value (low):</strong> Lowest discovery time reachable from subtree</li>
                <li><strong>Stack:</strong> Keeps track of vertices in current SCC being built</li>
            </ul>

            <div class="info-box">
                <h4><i class="fas fa-key"></i> SCC Root Detection</h4>
                <p>A vertex v is the root of an SCC when disc[v] == low[v]. At this point, all vertices on the stack up
                    to and including v form one SCC.</p>
            </div>

            <div class="code-box">
                time = <span class="number">0</span>
                disc = [-<span class="number">1</span>] * n
                low = [-<span class="number">1</span>] * n
                onStack = [<span class="keyword">false</span>] * n
                stack = []
                sccs = []

                <span class="keyword">function</span> <span class="function">tarjan</span>(graph, n):
                <span class="keyword">for</span> v = <span class="number">0</span> <span class="keyword">to</span>
                n-<span class="number">1</span>:
                <span class="keyword">if</span> disc[v] == -<span class="number">1</span>:
                <span class="function">dfs</span>(v, graph)
                <span class="keyword">return</span> sccs

                <span class="keyword">function</span> <span class="function">dfs</span>(v, graph):
                <span class="keyword">global</span> time
                disc[v] = low[v] = time
                time++
                stack.push(v)
                onStack[v] = <span class="keyword">true</span>

                <span class="keyword">for</span> u <span class="keyword">in</span> graph[v]:
                <span class="keyword">if</span> disc[u] == -<span class="number">1</span>: <span class="comment">// Not
                    visited</span>
                <span class="function">dfs</span>(u, graph)
                low[v] = min(low[v], low[u])
                <span class="keyword">else if</span> onStack[u]: <span class="comment">// Back edge to stack
                    vertex</span>
                low[v] = min(low[v], disc[u])

                <span class="comment">// If v is root of SCC (low[v] == disc[v])</span>
                <span class="keyword">if</span> low[v] == disc[v]:
                component = []
                <span class="keyword">while</span> <span class="keyword">true</span>:
                u = stack.pop()
                onStack[u] = <span class="keyword">false</span>
                component.append(u)
                <span class="keyword">if</span> u == v:
                <span class="keyword">break</span>
                sccs.append(component)
            </div>
        </div>

        <div class="card">
            <h2>Trace Example: Tarjan's Algorithm</h2>
            <div class="diagram-box">
                <pre>
Graph:  0 → 1 → 2
        ↑       ↓
        └───────3

Edges: 0→1, 1→2, 2→3, 3→0
                </pre>
            </div>

            <table class="comparison-table">
                <tr>
                    <th>Step</th>
                    <th>Visit</th>
                    <th>disc[]</th>
                    <th>low[]</th>
                    <th>Stack</th>
                    <th>Action</th>
                </tr>
                <tr>
                    <td>1</td>
                    <td>0</td>
                    <td>[0,-,-,-]</td>
                    <td>[0,-,-,-]</td>
                    <td>[0]</td>
                    <td>Visit 0</td>
                </tr>
                <tr>
                    <td>2</td>
                    <td>1</td>
                    <td>[0,1,-,-]</td>
                    <td>[0,1,-,-]</td>
                    <td>[0,1]</td>
                    <td>Visit 1</td>
                </tr>
                <tr>
                    <td>3</td>
                    <td>2</td>
                    <td>[0,1,2,-]</td>
                    <td>[0,1,2,-]</td>
                    <td>[0,1,2]</td>
                    <td>Visit 2</td>
                </tr>
                <tr>
                    <td>4</td>
                    <td>3</td>
                    <td>[0,1,2,3]</td>
                    <td>[0,1,2,3]</td>
                    <td>[0,1,2,3]</td>
                    <td>Visit 3</td>
                </tr>
                <tr>
                    <td>5</td>
                    <td>3→0</td>
                    <td>[0,1,2,3]</td>
                    <td>[0,1,2,0]</td>
                    <td>[0,1,2,3]</td>
                    <td>Back edge to 0</td>
                </tr>
                <tr>
                    <td>6</td>
                    <td>↑</td>
                    <td>[0,1,2,3]</td>
                    <td>[0,1,0,0]</td>
                    <td>[0,1,2,3]</td>
                    <td>Update low[2]</td>
                </tr>
                <tr>
                    <td>7</td>
                    <td>↑</td>
                    <td>[0,1,2,3]</td>
                    <td>[0,0,0,0]</td>
                    <td>[0,1,2,3]</td>
                    <td>Update low[1,0]</td>
                </tr>
                <tr>
                    <td>8</td>
                    <td>-</td>
                    <td>[0,1,2,3]</td>
                    <td>[0,0,0,0]</td>
                    <td>[]</td>
                    <td>low[0]==disc[0], pop SCC: {3,2,1,0}</td>
                </tr>
            </table>
            <p><strong>Result:</strong> One SCC containing all vertices {0, 1, 2, 3}</p>
        </div>

        <div class="card">
            <h2>Condensation Graph</h2>
            <p>The <strong>condensation graph</strong> (or meta-graph) is formed by collapsing each SCC into a single
                vertex. This graph is always a <strong>DAG</strong>.</p>

            <div class="diagram-box">
                <pre>
Original:                Condensation:
                         
┌───────────┐            
│ 1 ⟷ 2 ⟷ 3 │───→ 4     SCC{1,2,3} → SCC{4} → SCC{5,6}
└───────────┘     │      
                  ↓      (This is a DAG!)
            ┌─→ 5 ⟷ 6 ─┐
            └──────────┘
                </pre>
            </div>

            <h3>Building the Condensation Graph</h3>
            <ol>
                <li>Find all SCCs and assign each vertex to its SCC ID</li>
                <li>For each edge (u, v) in original graph, if SCC[u] ≠ SCC[v], add edge SCC[u] → SCC[v]</li>
                <li>Remove duplicate edges</li>
            </ol>
        </div>

        <div class="card">
            <h2>Comparison: Kosaraju vs Tarjan</h2>
            <table class="comparison-table">
                <tr>
                    <th>Aspect</th>
                    <th>Kosaraju's</th>
                    <th>Tarjan's</th>
                </tr>
                <tr>
                    <td>DFS Passes</td>
                    <td>2 passes</td>
                    <td>1 pass</td>
                </tr>
                <tr>
                    <td>Requires Graph Reversal</td>
                    <td>Yes</td>
                    <td>No</td>
                </tr>
                <tr>
                    <td>Extra Data Structures</td>
                    <td>Reversed graph + stack</td>
                    <td>disc[], low[], stack</td>
                </tr>
                <tr>
                    <td>Time Complexity</td>
                    <td>O(V + E)</td>
                    <td>O(V + E)</td>
                </tr>
                <tr>
                    <td>Space Complexity</td>
                    <td>O(V + E)</td>
                    <td>O(V)</td>
                </tr>
                <tr>
                    <td>Implementation</td>
                    <td>Easier to understand</td>
                    <td>More complex</td>
                </tr>
                <tr>
                    <td>Constant Factor</td>
                    <td>Higher (2 DFS)</td>
                    <td>Lower (1 DFS)</td>
                </tr>
            </table>
        </div>

        <div class="card">
            <h2>2-SAT Application</h2>
            <p>Strongly Connected Components are crucial for solving 2-SAT (2-Satisfiability) problems:</p>

            <h3>How 2-SAT Uses SCCs</h3>
            <ol>
                <li>Build implication graph: (x ∨ y) becomes (¬x → y) and (¬y → x)</li>
                <li>Find SCCs of the implication graph</li>
                <li>If any variable x and ¬x are in the same SCC → UNSATISFIABLE</li>
                <li>Otherwise, assign values based on SCC topological order</li>
            </ol>

            <div class="info-box">
                <h4><i class="fas fa-check-circle"></i> Why It Works</h4>
                <p>If x and ¬x are in the same SCC, there's a path x → ¬x and ¬x → x, meaning x implies ¬x and ¬x
                    implies x — a contradiction!</p>
            </div>
        </div>

        <div class="card">
            <h2>Time and Space Complexity</h2>
            <table class="comparison-table">
                <tr>
                    <th>Algorithm</th>
                    <th>Time</th>
                    <th>Space</th>
                </tr>
                <tr>
                    <td>Kosaraju's Algorithm</td>
                    <td>O(V + E)</td>
                    <td>O(V + E)</td>
                </tr>
                <tr>
                    <td>Tarjan's Algorithm</td>
                    <td>O(V + E)</td>
                    <td>O(V)</td>
                </tr>
                <tr>
                    <td>Build Condensation Graph</td>
                    <td>O(V + E)</td>
                    <td>O(V + E)</td>
                </tr>
            </table>
        </div>

        <div class="nav-buttons">
            <a href="mst-interactive.html" class="btn btn-secondary"><i class="fas fa-arrow-left"></i> Minimum Spanning
                Tree</a>
            <a href="flow-networks.html" class="btn btn-primary">Flow Networks <i class="fas fa-arrow-right"></i></a>
        </div>
    </div>
</body>

</html>