<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Red-Black Trees - Interactive Learning</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f5f5f5;
            min-height: 100vh;
        }

        .nav-bar {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            padding: 15px 30px;
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .nav-bar a {
            color: white;
            text-decoration: none;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .nav-bar h1 {
            color: white;
            font-size: 1.5em;
            flex: 1;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 40px 20px;
        }

        .card {
            background: white;
            border-radius: 16px;
            padding: 30px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            margin-bottom: 25px;
        }

        .card h2 {
            font-size: 1.8em;
            color: #1a1a2e;
            margin-bottom: 20px;
            border-bottom: 3px solid #ef4444;
            padding-bottom: 10px;
        }

        .card p {
            color: #555;
            line-height: 1.8;
            margin-bottom: 15px;
        }

        .property-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .property-card {
            background: #fef2f2;
            border-left: 4px solid #ef4444;
            padding: 20px;
            border-radius: 0 8px 8px 0;
        }

        .property-card h4 {
            color: #991b1b;
            margin-bottom: 10px;
        }

        .property-card p {
            color: #7f1d1d;
            margin: 0;
        }

        .info-box {
            background: #fef2f2;
            border: 2px solid #ef4444;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }

        .info-box h4 {
            color: #dc2626;
            margin-bottom: 10px;
        }

        .info-box p,
        .info-box li {
            color: #991b1b;
            line-height: 1.6;
        }

        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }

        .comparison-table th,
        .comparison-table td {
            padding: 12px 15px;
            border: 1px solid #e0e0e0;
            text-align: left;
        }

        .comparison-table th {
            background: #ef4444;
            color: white;
        }

        .comparison-table tr:nth-child(even) {
            background: #f8f8f8;
        }

        .nav-buttons {
            display: flex;
            justify-content: space-between;
            margin-top: 40px;
            padding-top: 30px;
            border-top: 2px solid #e0e0e0;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            text-decoration: none;
        }

        .btn-primary {
            background: #ef4444;
            color: white;
        }

        .btn-secondary {
            background: white;
            color: #1a1a2e;
            border: 2px solid #e0e0e0;
        }

        .code-box {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
            border-radius: 8px;
            font-family: monospace;
            font-size: 14px;
            margin: 15px 0;
            overflow-x: auto;
        }
    </style>
</head>

<body>
    <div class="nav-bar">
        <a href="index.html"><i class="fas fa-home"></i> Home</a>
        <h1><i class="fas fa-yin-yang"></i> Red-Black Trees</h1>
        <a href="heap-trees.html">Next: Heap Trees <i class="fas fa-arrow-right"></i></a>
    </div>
    <div class="container">
        <div class="card">
            <h2>What is a Red-Black Tree?</h2>
            <p>A <strong>Red-Black Tree</strong> is a self-balancing binary search tree where each node has a color (red
                or black). The tree maintains balance through a set of coloring rules that ensure the longest path is at
                most twice as long as the shortest path.</p>
            <div class="info-box">
                <h4><i class="fas fa-key"></i> Key Insight</h4>
                <p>Red-Black trees provide O(log n) guarantees for search, insert, and delete operations, with less
                    strict balancing than AVL trees, resulting in faster insertions and deletions on average.</p>
            </div>
        </div>
        <div class="card">
            <h2>Red-Black Properties</h2>
            <div class="property-grid">
                <div class="property-card">
                    <h4>1. Node Colors</h4>
                    <p>Every node is either RED or BLACK.</p>
                </div>
                <div class="property-card">
                    <h4>2. Root Property</h4>
                    <p>The root is always BLACK.</p>
                </div>
                <div class="property-card">
                    <h4>3. Leaf Property</h4>
                    <p>All NULL leaves are considered BLACK.</p>
                </div>
                <div class="property-card">
                    <h4>4. Red Property</h4>
                    <p>If a node is RED, both its children must be BLACK (no two consecutive reds).</p>
                </div>
                <div class="property-card">
                    <h4>5. Black Height</h4>
                    <p>Every path from a node to its descendant NULL leaves has the same number of BLACK nodes.</p>
                </div>
            </div>
        </div>
        <div class="card">
            <h2>AVL vs Red-Black Trees</h2>
            <table class="comparison-table">
                <tr>
                    <th>Property</th>
                    <th>AVL Tree</th>
                    <th>Red-Black Tree</th>
                </tr>
                <tr>
                    <td>Balance strictness</td>
                    <td>More strictly balanced</td>
                    <td>Less strictly balanced</td>
                </tr>
                <tr>
                    <td>Search</td>
                    <td>Slightly faster</td>
                    <td>Slightly slower</td>
                </tr>
                <tr>
                    <td>Insert/Delete</td>
                    <td>More rotations needed</td>
                    <td>Fewer rotations (≤2)</td>
                </tr>
                <tr>
                    <td>Space overhead</td>
                    <td>Balance factor (int)</td>
                    <td>Color bit (1 bit)</td>
                </tr>
                <tr>
                    <td>Use case</td>
                    <td>Lookup-intensive</td>
                    <td>Insert/delete-intensive</td>
                </tr>
                <tr>
                    <td>Used in</td>
                    <td>Databases</td>
                    <td>Linux kernel, Java TreeMap</td>
                </tr>
            </table>
        </div>
        <div class="card">
            <h2>Rotations</h2>
            <p>Rotations are the fundamental operations used to rebalance the tree. They change the structure while
                preserving the BST property.</p>

            <div class="property-grid">
                <div class="property-card">
                    <h4><i class="fas fa-undo"></i> Left Rotation</h4>
                    <p>Rotate a node down-left. Its right child becomes its parent.</p>
                </div>
                <div class="property-card">
                    <h4><i class="fas fa-redo"></i> Right Rotation</h4>
                    <p>Rotate a node down-right. Its left child becomes its parent.</p>
                </div>
            </div>

            <div class="code-box">
                x y
                / \ Left Rotate(x) / \
                a y ───────────────► x c
                / \ / \
                b c a b

                y x
                / \ Right Rotate(y) / \
                x c ───────────────► a y
                / \ / \
                a b b c
            </div>
        </div>

        <div class="card">
            <h2>Insertion Algorithm</h2>
            <p>Insertion follows standard BST insertion, then fixes any violated Red-Black properties.</p>

            <h3>Steps</h3>
            <ol style="margin-left: 25px;">
                <li>Insert node as RED (like standard BST)</li>
                <li>If parent is BLACK → done (no violation)</li>
                <li>If parent is RED → violation! Call fixup procedure</li>
            </ol>

            <div class="code-box">
                function insert(root, key):
                // Standard BST insert
                node = new Node(key)
                node.color = RED
                root = bstInsert(root, node)

                // Fix Red-Black violations
                fixInsert(node)
                return root
            </div>
        </div>

        <div class="card">
            <h2>Insertion Fixup Cases</h2>
            <p>Let z be the newly inserted RED node. The fixup handles cases based on z's uncle color.</p>

            <div class="property-grid">
                <div class="property-card" style="background: #fef9c3;">
                    <h4>Case 1: Uncle is RED</h4>
                    <p>Recolor parent, uncle to BLACK. Recolor grandparent to RED. Move z to grandparent and repeat.</p>
                </div>
                <div class="property-card" style="background: #fee2e2;">
                    <h4>Case 2: Uncle is BLACK (Triangle)</h4>
                    <p>z is inner child (left-right or right-left). Rotate parent to make it Case 3.</p>
                </div>
                <div class="property-card" style="background: #dcfce7;">
                    <h4>Case 3: Uncle is BLACK (Line)</h4>
                    <p>z is outer child. Rotate grandparent opposite direction. Swap parent/grandparent colors.</p>
                </div>
            </div>

            <div class="code-box">
                function fixInsert(z):
                while z.parent.color == RED:
                if z.parent == z.parent.parent.left:
                uncle = z.parent.parent.right

                if uncle.color == RED: // Case 1
                z.parent.color = BLACK
                uncle.color = BLACK
                z.parent.parent.color = RED
                z = z.parent.parent
                else:
                if z == z.parent.right: // Case 2
                z = z.parent
                leftRotate(z)
                // Case 3
                z.parent.color = BLACK
                z.parent.parent.color = RED
                rightRotate(z.parent.parent)
                else:
                // Symmetric: swap left/right
                ... (mirror cases)

                root.color = BLACK
            </div>
        </div>

        <div class="card">
            <h2>Insertion Example</h2>
            <div class="code-box">
                Insert sequence: 10, 20, 30, 15

                Step 1: Insert 10 Step 2: Insert 20
                (10B) (10B)
                \
                (20R)

                Step 3: Insert 30 → Case 3 (Line: right-right)
                (10B) rotate left (20B)
                \ ──────────► / \
                (20R) (10R) (30R)
                \
                (30R)

                Step 4: Insert 15 → Case 1 (Uncle red)
                (20B) recolor (20B)
                / \ ──────────► / \
                (10R) (30R) (10B) (30B)
                \ \
                (15R) (15R)
            </div>
        </div>

        <div class="card">
            <h2>Deletion Algorithm</h2>
            <p>Deletion is more complex. We first do BST deletion, then fix any violations.</p>

            <h3>Key Insight</h3>
            <p>If we delete a BLACK node, it reduces the black-height on that path, violating property 5. We need to fix
                this with a "double black" propagation.</p>

            <div class="code-box">
                function delete(root, key):
                z = search(root, key)
                if z == NULL:
                return root

                y = z // Node to be removed
                yOriginalColor = y.color

                if z.left == NULL:
                x = z.right
                transplant(z, z.right)
                else if z.right == NULL:
                x = z.left
                transplant(z, z.left)
                else:
                y = minimum(z.right) // Successor
                yOriginalColor = y.color
                x = y.right
                if y.parent == z:
                x.parent = y
                else:
                transplant(y, y.right)
                y.right = z.right
                y.right.parent = y
                transplant(z, y)
                y.left = z.left
                y.left.parent = y
                y.color = z.color

                if yOriginalColor == BLACK:
                fixDelete(x)
            </div>
        </div>

        <div class="card">
            <h2>Deletion Fixup Cases</h2>
            <p>x is the node that replaced the deleted node. Sibling w is x's sibling.</p>

            <div class="property-grid">
                <div class="property-card" style="background: #fee2e2;">
                    <h4>Case 1: Sibling is RED</h4>
                    <p>Swap sibling/parent colors. Rotate parent toward x. Now sibling is BLACK, continue to other
                        cases.</p>
                </div>
                <div class="property-card" style="background: #e0e7ff;">
                    <h4>Case 2: Sibling BLACK, both nephews BLACK</h4>
                    <p>Color sibling RED. Move double-black up to parent. Repeat fixup from parent.</p>
                </div>
                <div class="property-card" style="background: #fef9c3;">
                    <h4>Case 3: Sibling BLACK, near nephew RED</h4>
                    <p>Swap sibling/near-nephew colors. Rotate sibling away from x. This creates Case 4.</p>
                </div>
                <div class="property-card" style="background: #dcfce7;">
                    <h4>Case 4: Sibling BLACK, far nephew RED</h4>
                    <p>Sibling takes parent's color. Parent and far nephew become BLACK. Rotate parent toward x. Done!
                    </p>
                </div>
            </div>

            <div class="code-box">
                function fixDelete(x):
                while x != root and x.color == BLACK:
                if x == x.parent.left:
                w = x.parent.right // Sibling

                if w.color == RED: // Case 1
                w.color = BLACK
                x.parent.color = RED
                leftRotate(x.parent)
                w = x.parent.right

                if w.left.color == BLACK and w.right.color == BLACK: // Case 2
                w.color = RED
                x = x.parent
                else:
                if w.right.color == BLACK: // Case 3
                w.left.color = BLACK
                w.color = RED
                rightRotate(w)
                w = x.parent.right

                // Case 4
                w.color = x.parent.color
                x.parent.color = BLACK
                w.right.color = BLACK
                leftRotate(x.parent)
                x = root
                else:
                // Symmetric: swap left/right
                ...

                x.color = BLACK
            </div>
        </div>

        <div class="card">
            <h2>Operations Complexity</h2>
            <p>All operations in Red-Black Trees are O(log n):</p>
            <table class="comparison-table">
                <tr>
                    <th>Operation</th>
                    <th>Time</th>
                    <th>Rotations</th>
                </tr>
                <tr>
                    <td>Search</td>
                    <td>O(log n)</td>
                    <td>0</td>
                </tr>
                <tr>
                    <td>Insert</td>
                    <td>O(log n)</td>
                    <td>At most 2</td>
                </tr>
                <tr>
                    <td>Delete</td>
                    <td>O(log n)</td>
                    <td>At most 3</td>
                </tr>
                <tr>
                    <td>Fixup (recoloring)</td>
                    <td>O(log n)</td>
                    <td>-</td>
                </tr>
            </table>
            <p>The height of a Red-Black tree is at most 2 × log₂(n + 1), guaranteeing logarithmic operations.</p>
        </div>

        <div class="card">
            <h2>Real-World Usage</h2>
            <ul style="margin-left: 25px;">
                <li><strong>Linux Kernel:</strong> Completely Fair Scheduler (CFS), memory management</li>
                <li><strong>Java:</strong> TreeMap, TreeSet implementations</li>
                <li><strong>C++ STL:</strong> std::map, std::set (often Red-Black trees)</li>
                <li><strong>Databases:</strong> Some index implementations</li>
            </ul>
        </div>

        <div class="nav-buttons">
            <a href="avl-trees.html" class="btn btn-secondary"><i class="fas fa-arrow-left"></i> AVL Trees</a>
            <a href="heap-trees.html" class="btn btn-primary">Heap Trees <i class="fas fa-arrow-right"></i></a>
        </div>
    </div>
</body>

</html>