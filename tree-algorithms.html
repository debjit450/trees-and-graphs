<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tree Algorithms - Interactive Learning</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f5f5f5;
            min-height: 100vh;
        }

        .nav-bar {
            background: linear-gradient(135deg, #0ea5e9 0%, #0284c7 100%);
            padding: 15px 30px;
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .nav-bar a {
            color: white;
            text-decoration: none;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .nav-bar h1 {
            color: white;
            font-size: 1.5em;
            flex: 1;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 40px 20px;
        }

        .main-grid {
            display: grid;
            grid-template-columns: 1fr 380px;
            gap: 30px;
        }

        @media (max-width: 1100px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
        }

        .card {
            background: white;
            border-radius: 16px;
            padding: 30px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            margin-bottom: 25px;
        }

        .card h2 {
            font-size: 1.5em;
            color: #1a1a2e;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
            border-bottom: 3px solid #0ea5e9;
            padding-bottom: 10px;
        }

        .card h2 i {
            color: #0ea5e9;
        }

        .canvas-container {
            background: #f8f8f8;
            border-radius: 12px;
            padding: 20px;
            text-align: center;
        }

        canvas {
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            background: white;
            cursor: pointer;
        }

        .controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 20px;
            align-items: center;
        }

        .btn {
            padding: 12px 20px;
            border: 2px solid transparent;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .btn-primary {
            background: #0ea5e9;
            color: white;
        }

        .btn-primary:hover {
            background: #0284c7;
        }

        .btn-success {
            background: #10b981;
            color: white;
        }

        .btn-success:hover {
            background: #059669;
        }

        .btn-warning {
            background: #f59e0b;
            color: white;
        }

        .btn-warning:hover {
            background: #d97706;
        }

        .btn-info {
            background: #8b5cf6;
            color: white;
        }

        .btn-info:hover {
            background: #7c3aed;
        }

        .btn-danger {
            background: #ef4444;
            color: white;
        }

        .btn-danger:hover {
            background: #dc2626;
        }

        .btn-secondary {
            background: white;
            color: #1a1a2e;
            border-color: #e0e0e0;
        }

        .btn-secondary:hover {
            border-color: #0ea5e9;
            color: #0ea5e9;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .info-box {
            background: #e0f2fe;
            border: 2px solid #0ea5e9;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }

        .info-box h4 {
            color: #0284c7;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .info-box p,
        .info-box li {
            color: #075985;
            line-height: 1.6;
        }

        .output-box {
            background: #f8f8f8;
            border-radius: 8px;
            padding: 20px;
            margin-top: 20px;
            border-left: 4px solid #0ea5e9;
        }

        .output-box h3 {
            font-size: 1.1em;
            margin-bottom: 10px;
            color: #1a1a2e;
        }

        .output-content {
            font-family: 'Courier New', monospace;
            font-size: 18px;
            color: #0ea5e9;
            min-height: 24px;
        }

        .step-info {
            background: #0ea5e9;
            color: white;
            padding: 15px 20px;
            border-radius: 8px;
            font-weight: 600;
            margin: 15px 0;
            display: none;
        }

        .step-info.active {
            display: block;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin: 20px 0;
        }

        .stat-item {
            text-align: center;
            padding: 15px;
            background: #f8f8f8;
            border-radius: 8px;
        }

        .stat-value {
            font-size: 24px;
            font-weight: 700;
            color: #0ea5e9;
        }

        .stat-label {
            font-size: 12px;
            color: #666;
        }

        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 15px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 14px;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: 2px solid #333;
        }

        .code-box {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            overflow-x: auto;
            margin: 15px 0;
        }

        .code-box .keyword {
            color: #569cd6;
        }

        .code-box .comment {
            color: #6a9955;
        }

        .code-box .function {
            color: #dcdcaa;
        }

        ul.concept-list {
            list-style: none;
            padding: 0;
        }

        ul.concept-list li {
            padding: 10px 0;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            align-items: flex-start;
            gap: 10px;
            font-size: 14px;
        }

        ul.concept-list li:last-child {
            border-bottom: none;
        }

        ul.concept-list li i {
            color: #0ea5e9;
            margin-top: 3px;
        }

        .node-select {
            padding: 8px;
            background: #f8f8f8;
            border-radius: 8px;
            margin: 15px 0;
        }

        .node-select label {
            font-weight: 600;
            margin-right: 10px;
        }

        .node-select select {
            padding: 8px 16px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
        }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 15px;
            margin: 20px 0;
        }

        .speed-control label {
            font-weight: 600;
            color: #1a1a2e;
        }

        input[type="range"] {
            width: 150px;
        }
    </style>
</head>

<body>
    <div class="nav-bar">
        <a href="index.html"><i class="fas fa-home"></i> Home</a>
        <h1><i class="fas fa-code-branch"></i> Tree Algorithms</h1>
        <a href="topological-sort.html">Next: Topological Sort <i class="fas fa-arrow-right"></i></a>
    </div>

    <div class="container">
        <div class="main-grid">
            <div class="left-column">
                <div class="card">
                    <h2><i class="fas fa-sitemap"></i> Tree Visualizer</h2>

                    <div class="canvas-container">
                        <canvas id="treeCanvas" width="750" height="380"></canvas>
                    </div>

                    <div class="controls" style="margin-top: 20px;">
                        <button class="btn btn-primary" onclick="loadTree('binary')">
                            <i class="fas fa-sitemap"></i> Binary Tree
                        </button>
                        <button class="btn btn-primary" onclick="loadTree('balanced')">
                            <i class="fas fa-balance-scale"></i> Balanced
                        </button>
                        <button class="btn btn-primary" onclick="loadTree('path')">
                            <i class="fas fa-route"></i> Path Graph
                        </button>
                        <button class="btn btn-secondary" onclick="resetTree()">
                            <i class="fas fa-undo"></i> Reset
                        </button>
                    </div>

                    <div class="node-select">
                        <label>Node 1:</label>
                        <select id="node1Select"></select>
                        <label style="margin-left: 20px;">Node 2:</label>
                        <select id="node2Select"></select>
                    </div>

                    <div class="stats-grid">
                        <div class="stat-item">
                            <div class="stat-value" id="nodeCount">0</div>
                            <div class="stat-label">Nodes</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="edgeCount">0</div>
                            <div class="stat-label">Edges</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="treeHeight">0</div>
                            <div class="stat-label">Height</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="diameter">-</div>
                            <div class="stat-label">Diameter</div>
                        </div>
                    </div>

                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background: #0ea5e9;"></div> Normal
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #10b981;"></div> Selected
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #f59e0b;"></div> Path
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #ef4444;"></div> LCA
                        </div>
                    </div>
                </div>

                <div class="card">
                    <h2><i class="fas fa-play-circle"></i> Run Algorithms</h2>

                    <div class="step-info" id="stepInfo"></div>

                    <div class="controls">
                        <button class="btn btn-success" onclick="findLCA()">
                            <i class="fas fa-code-branch"></i> Find LCA
                        </button>
                        <button class="btn btn-warning" onclick="findDiameter()">
                            <i class="fas fa-arrows-alt-h"></i> Tree Diameter
                        </button>
                        <button class="btn btn-info" onclick="findDistance()">
                            <i class="fas fa-ruler"></i> Distance
                        </button>
                    </div>

                    <div class="speed-control">
                        <label>Animation Speed:</label>
                        <input type="range" id="speedSlider" min="200" max="1500" value="400" step="100">
                        <span id="speedLabel">0.4s</span>
                    </div>

                    <div class="output-box">
                        <h3><i class="fas fa-info-circle"></i> Result</h3>
                        <div class="output-content" id="resultOutput">Select two nodes and run an algorithm</div>
                    </div>
                </div>
            </div>

            <div class="right-column">
                <div class="card">
                    <h2><i class="fas fa-code-branch"></i> Lowest Common Ancestor</h2>
                    <div class="info-box">
                        <h4><i class="fas fa-key"></i> Definition</h4>
                        <p>LCA(u, v) is the deepest node that is an ancestor of both u and v.</p>
                    </div>
                    <div class="code-box">
                        <span class="comment">// Simple O(n) approach</span>
                        <span class="keyword">function</span> <span class="function">findLCA</span>(root, u, v):
                        <span class="keyword">if</span> root == null: <span class="keyword">return</span> null
                        <span class="keyword">if</span> root == u or root == v: <span class="keyword">return</span> root

                        left = <span class="function">findLCA</span>(root.left, u, v)
                        right = <span class="function">findLCA</span>(root.right, u, v)

                        <span class="keyword">if</span> left && right: <span class="keyword">return</span> root
                        <span class="keyword">return</span> left ? left : right
                    </div>
                    <p style="margin-top: 10px; color: #666;"><strong>Advanced:</strong> Binary Lifting gives O(log n)
                        per query after O(n log n) preprocessing.</p>
                </div>

                <div class="card">
                    <h2><i class="fas fa-arrows-alt-h"></i> Tree Diameter</h2>
                    <div class="info-box">
                        <h4><i class="fas fa-key"></i> Definition</h4>
                        <p>The longest path between any two nodes in the tree.</p>
                    </div>
                    <div class="code-box">
                        <span class="comment">// Two BFS/DFS approach</span>
                        <span class="keyword">function</span> <span class="function">treeDiameter</span>(root):
                        <span class="comment">// BFS from any node to find farthest</span>
                        farthest = <span class="function">bfs</span>(root)

                        <span class="comment">// BFS from farthest to find diameter</span>
                        endpoint, dist = <span class="function">bfs</span>(farthest)

                        <span class="keyword">return</span> dist
                    </div>
                    <p style="margin-top: 10px; color: #666;"><strong>Alternative:</strong> Single DFS computing
                        max(height(left) + height(right)) at each node.</p>
                </div>

                <div class="card">
                    <h2><i class="fas fa-ruler"></i> Distance Between Nodes</h2>
                    <div class="info-box">
                        <h4><i class="fas fa-lightbulb"></i> Formula</h4>
                        <p>dist(u, v) = depth(u) + depth(v) - 2 × depth(LCA(u, v))</p>
                    </div>
                    <p style="margin-top: 10px; color: #666;">Once you have LCA, distance computation is O(1) with
                        precomputed depths.</p>
                </div>

                <div class="card">
                    <h2><i class="fas fa-rocket"></i> Applications</h2>
                    <ul class="concept-list">
                        <li><i class="fas fa-network-wired"></i> <strong>Network routing</strong></li>
                        <li><i class="fas fa-dna"></i> <strong>Phylogenetic trees</strong></li>
                        <li><i class="fas fa-folder-tree"></i> <strong>File system paths</strong></li>
                        <li><i class="fas fa-code"></i> <strong>Expression trees</strong></li>
                        <li><i class="fas fa-sitemap"></i> <strong>Organization hierarchy</strong></li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('treeCanvas');
        const ctx = canvas.getContext('2d');

        let nodes = [];
        let edges = [];
        let isAnimating = false;
        let animationSpeed = 400;
        let root = null;

        document.getElementById('speedSlider').addEventListener('input', function (e) {
            animationSpeed = parseInt(e.target.value);
            document.getElementById('speedLabel').textContent = (animationSpeed / 1000).toFixed(1) + 's';
        });

        function loadTree(type) {
            nodes = [];
            edges = [];

            if (type === 'binary') {
                nodes = [
                    { id: 0, label: 'A', x: 375, y: 50, parent: null, state: 'normal', depth: 0 },
                    { id: 1, label: 'B', x: 200, y: 130, parent: 0, state: 'normal', depth: 1 },
                    { id: 2, label: 'C', x: 550, y: 130, parent: 0, state: 'normal', depth: 1 },
                    { id: 3, label: 'D', x: 120, y: 220, parent: 1, state: 'normal', depth: 2 },
                    { id: 4, label: 'E', x: 280, y: 220, parent: 1, state: 'normal', depth: 2 },
                    { id: 5, label: 'F', x: 470, y: 220, parent: 2, state: 'normal', depth: 2 },
                    { id: 6, label: 'G', x: 630, y: 220, parent: 2, state: 'normal', depth: 2 },
                    { id: 7, label: 'H', x: 80, y: 310, parent: 3, state: 'normal', depth: 3 },
                    { id: 8, label: 'I', x: 160, y: 310, parent: 3, state: 'normal', depth: 3 }
                ];
                root = 0;
            } else if (type === 'balanced') {
                nodes = [
                    { id: 0, label: 'A', x: 375, y: 60, parent: null, state: 'normal', depth: 0 },
                    { id: 1, label: 'B', x: 225, y: 150, parent: 0, state: 'normal', depth: 1 },
                    { id: 2, label: 'C', x: 525, y: 150, parent: 0, state: 'normal', depth: 1 },
                    { id: 3, label: 'D', x: 150, y: 250, parent: 1, state: 'normal', depth: 2 },
                    { id: 4, label: 'E', x: 300, y: 250, parent: 1, state: 'normal', depth: 2 },
                    { id: 5, label: 'F', x: 450, y: 250, parent: 2, state: 'normal', depth: 2 },
                    { id: 6, label: 'G', x: 600, y: 250, parent: 2, state: 'normal', depth: 2 }
                ];
                root = 0;
            } else if (type === 'path') {
                const startX = 100, stepX = 100, y = 190;
                for (let i = 0; i < 7; i++) {
                    nodes.push({
                        id: i,
                        label: String.fromCharCode(65 + i),
                        x: startX + i * stepX,
                        y: y,
                        parent: i > 0 ? i - 1 : null,
                        state: 'normal',
                        depth: i
                    });
                }
                root = 0;
            }

            // Build edges from parent relationships
            edges = [];
            nodes.forEach(n => {
                if (n.parent !== null) {
                    edges.push({ from: n.parent, to: n.id, state: 'normal' });
                }
            });

            updateNodeSelectors();
            updateStats();
            drawTree();
        }

        function updateNodeSelectors() {
            const sel1 = document.getElementById('node1Select');
            const sel2 = document.getElementById('node2Select');
            sel1.innerHTML = '';
            sel2.innerHTML = '';

            nodes.forEach(n => {
                sel1.innerHTML += `<option value="${n.id}">${n.label}</option>`;
                sel2.innerHTML += `<option value="${n.id}">${n.label}</option>`;
            });

            if (nodes.length > 1) {
                sel2.value = nodes[nodes.length - 1].id;
            }
        }

        function resetTree() {
            nodes.forEach(n => n.state = 'normal');
            edges.forEach(e => e.state = 'normal');
            document.getElementById('stepInfo').classList.remove('active');
            document.getElementById('resultOutput').textContent = 'Select two nodes and run an algorithm';
            drawTree();
        }

        function updateStats() {
            document.getElementById('nodeCount').textContent = nodes.length;
            document.getElementById('edgeCount').textContent = edges.length;

            const maxDepth = nodes.length > 0 ? Math.max(...nodes.map(n => n.depth)) : 0;
            document.getElementById('treeHeight').textContent = maxDepth;
        }

        function getNodeById(id) {
            return nodes.find(n => n.id === id);
        }

        function drawTree() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (nodes.length === 0) {
                ctx.font = '16px Segoe UI';
                ctx.fillStyle = '#666';
                ctx.textAlign = 'center';
                ctx.fillText('Load a tree to get started', canvas.width / 2, canvas.height / 2);
                return;
            }

            // Draw edges
            edges.forEach(edge => {
                const from = getNodeById(edge.from);
                const to = getNodeById(edge.to);
                if (!from || !to) return;

                ctx.beginPath();
                ctx.moveTo(from.x, from.y);
                ctx.lineTo(to.x, to.y);

                if (edge.state === 'path') {
                    ctx.strokeStyle = '#f59e0b';
                    ctx.lineWidth = 4;
                } else if (edge.state === 'diameter') {
                    ctx.strokeStyle = '#ef4444';
                    ctx.lineWidth = 5;
                } else {
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 2;
                }
                ctx.stroke();
            });

            // Draw nodes
            nodes.forEach(node => {
                ctx.beginPath();
                ctx.arc(node.x, node.y, 22, 0, 2 * Math.PI);

                let color = '#0ea5e9';
                if (node.state === 'selected') color = '#10b981';
                else if (node.state === 'path') color = '#f59e0b';
                else if (node.state === 'lca') color = '#ef4444';
                else if (node.state === 'farthest') color = '#8b5cf6';

                ctx.fillStyle = color;
                ctx.fill();
                ctx.strokeStyle = '#1a1a2e';
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.font = 'bold 16px Segoe UI';
                ctx.fillStyle = 'white';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(node.label, node.x, node.y);

                // Show depth
                ctx.font = '10px Segoe UI';
                ctx.fillStyle = '#666';
                ctx.fillText(`d=${node.depth}`, node.x, node.y + 35);
            });
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function getPath(nodeId, pathSet) {
            let current = getNodeById(nodeId);
            while (current) {
                pathSet.add(current.id);
                if (current.parent === null) break;
                current = getNodeById(current.parent);
            }
        }

        async function findLCA() {
            if (isAnimating || nodes.length === 0) return;
            isAnimating = true;
            resetTree();

            const node1Id = parseInt(document.getElementById('node1Select').value);
            const node2Id = parseInt(document.getElementById('node2Select').value);

            const node1 = getNodeById(node1Id);
            const node2 = getNodeById(node2Id);

            const stepInfo = document.getElementById('stepInfo');
            stepInfo.classList.add('active');

            node1.state = 'selected';
            node2.state = 'selected';
            stepInfo.textContent = `Finding LCA of ${node1.label} and ${node2.label}`;
            drawTree();
            await sleep(animationSpeed);

            // Get ancestors of node1
            const ancestors1 = new Set();
            getPath(node1Id, ancestors1);

            // Find first common ancestor from node2's path
            let current = node2Id;
            let lca = null;

            while (current !== null) {
                const node = getNodeById(current);
                node.state = 'path';
                drawTree();
                await sleep(animationSpeed / 2);

                if (ancestors1.has(current)) {
                    lca = node;
                    node.state = 'lca';
                    stepInfo.textContent = `Found LCA: ${node.label}`;
                    break;
                }

                current = node.parent;
            }

            // Highlight path from node1 to LCA
            current = node1Id;
            while (current !== lca.id) {
                const node = getNodeById(current);
                node.state = 'path';

                const edge = edges.find(e =>
                    (e.from === current && e.to === node.parent) ||
                    (e.to === current && e.from === node.parent)
                );
                if (edge) edge.state = 'path';

                current = node.parent;
            }

            // Highlight path from node2 to LCA
            current = node2Id;
            while (current !== lca.id) {
                const node = getNodeById(current);
                if (node.state !== 'lca') node.state = 'path';

                const edge = edges.find(e =>
                    (e.from === current && e.to === node.parent) ||
                    (e.to === current && e.from === node.parent)
                );
                if (edge) edge.state = 'path';

                current = node.parent;
            }

            lca.state = 'lca';
            drawTree();

            document.getElementById('resultOutput').textContent = `LCA(${node1.label}, ${node2.label}) = ${lca.label}`;

            isAnimating = false;
        }

        async function findDiameter() {
            if (isAnimating || nodes.length === 0) return;
            isAnimating = true;
            resetTree();

            const stepInfo = document.getElementById('stepInfo');
            stepInfo.classList.add('active');

            // BFS to find farthest from root
            stepInfo.textContent = 'Finding farthest node from root...';
            drawTree();
            await sleep(animationSpeed);

            let farthest1 = findFarthestBFS(root);
            getNodeById(farthest1.id).state = 'farthest';
            stepInfo.textContent = `Farthest from root: ${getNodeById(farthest1.id).label}`;
            drawTree();
            await sleep(animationSpeed);

            // BFS from farthest1 to find other endpoint
            resetTree();
            getNodeById(farthest1.id).state = 'farthest';
            stepInfo.textContent = `Finding farthest from ${getNodeById(farthest1.id).label}...`;
            drawTree();
            await sleep(animationSpeed);

            let farthest2 = findFarthestBFS(farthest1.id);
            getNodeById(farthest2.id).state = 'farthest';

            // Highlight diameter path
            highlightPath(farthest1.id, farthest2.id);

            const diameter = farthest2.dist;
            document.getElementById('diameter').textContent = diameter;
            document.getElementById('resultOutput').textContent = `Diameter = ${diameter} (from ${getNodeById(farthest1.id).label} to ${getNodeById(farthest2.id).label})`;
            stepInfo.textContent = `Diameter: ${diameter} edges`;

            drawTree();
            isAnimating = false;
        }

        function findFarthestBFS(startId) {
            const dist = {};
            const parent = {};
            nodes.forEach(n => { dist[n.id] = -1; parent[n.id] = null; });

            dist[startId] = 0;
            const queue = [startId];
            let farthest = { id: startId, dist: 0 };

            while (queue.length > 0) {
                const nodeId = queue.shift();
                const node = getNodeById(nodeId);

                // Get all neighbors (parent + children)
                const neighbors = [];
                if (node.parent !== null) neighbors.push(node.parent);
                nodes.filter(n => n.parent === nodeId).forEach(n => neighbors.push(n.id));

                for (let neighborId of neighbors) {
                    if (dist[neighborId] === -1) {
                        dist[neighborId] = dist[nodeId] + 1;
                        parent[neighborId] = nodeId;
                        queue.push(neighborId);

                        if (dist[neighborId] > farthest.dist) {
                            farthest = { id: neighborId, dist: dist[neighborId] };
                        }
                    }
                }
            }

            return farthest;
        }

        function highlightPath(startId, endId) {
            // Use LCA to find path
            const ancestors1 = new Set();
            let current = startId;
            while (current !== null) {
                ancestors1.add(current);
                current = getNodeById(current).parent;
            }

            // Find LCA
            current = endId;
            let lca = null;
            while (current !== null) {
                if (ancestors1.has(current)) {
                    lca = current;
                    break;
                }
                current = getNodeById(current).parent;
            }

            // Highlight path through LCA
            const highlightEdge = (from, to) => {
                const edge = edges.find(e =>
                    (e.from === from && e.to === to) ||
                    (e.to === from && e.from === to)
                );
                if (edge) edge.state = 'diameter';
            };

            current = startId;
            while (current !== lca) {
                getNodeById(current).state = 'path';
                highlightEdge(current, getNodeById(current).parent);
                current = getNodeById(current).parent;
            }
            getNodeById(lca).state = 'path';

            current = endId;
            while (current !== lca) {
                getNodeById(current).state = 'path';
                highlightEdge(current, getNodeById(current).parent);
                current = getNodeById(current).parent;
            }
        }

        async function findDistance() {
            if (isAnimating || nodes.length === 0) return;
            isAnimating = true;
            resetTree();

            const node1Id = parseInt(document.getElementById('node1Select').value);
            const node2Id = parseInt(document.getElementById('node2Select').value);

            const node1 = getNodeById(node1Id);
            const node2 = getNodeById(node2Id);

            const stepInfo = document.getElementById('stepInfo');
            stepInfo.classList.add('active');

            node1.state = 'selected';
            node2.state = 'selected';
            stepInfo.textContent = `Finding distance between ${node1.label} and ${node2.label}`;
            drawTree();
            await sleep(animationSpeed);

            // Find LCA first
            const ancestors1 = new Set();
            getPath(node1Id, ancestors1);

            let current = node2Id;
            let lca = null;
            while (current !== null) {
                if (ancestors1.has(current)) {
                    lca = getNodeById(current);
                    break;
                }
                current = getNodeById(current).parent;
            }

            // Calculate distance
            const depth1 = node1.depth;
            const depth2 = node2.depth;
            const lcaDepth = lca.depth;
            const distance = (depth1 - lcaDepth) + (depth2 - lcaDepth);

            // Highlight path
            highlightPath(node1Id, node2Id);
            lca.state = 'lca';
            node1.state = 'selected';
            node2.state = 'selected';

            document.getElementById('resultOutput').textContent =
                `dist(${node1.label}, ${node2.label}) = ${depth1} + ${depth2} - 2×${lcaDepth} = ${distance}`;
            stepInfo.textContent = `Distance: ${distance} (via LCA ${lca.label})`;

            drawTree();
            isAnimating = false;
        }

        // Initial load
        loadTree('binary');
    </script>
</body>

</html>